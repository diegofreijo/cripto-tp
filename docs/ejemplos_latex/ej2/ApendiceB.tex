\section{Apéndice B}

\subsection{Funciones Relevantes}

\begin{scriptsize}
\begin{verbatim}

/**
 * Triangular la matriz *this modificando también b
 * No hace el despeje. Se detiene si la matriz *this representa a un sistema incompatible
 * o indeterminado (devolviendo false).
 * Devuelve true si la matriz representa un sistema determinado con igual cantidad de
 * filas no completamente iguales a 0 que columnas.
 */
bool clase::triangular(clase& b)
{

	assert(getFil() == b.getFil());
  bool rv = true;
	// Se hará pivoteo parcial. Guardar un vector de subíndices para cada fila
	unsigned int nrow[getFil()];
	for (uint_t i = 0; i < getFil(); i++)
		nrow[i] = i+1; // inicialmente la fila i-ésima es la verdadera fila i
	// Triangular la matriz
	// Poner en la fila i-ésima la que tiene el elemento en la columna 
	// i-ésima con valor absoluto más grande
	
	for (uint_t i = 1; i <= getFil(); i++) {
    // i es la fila "lógica" que se está procesando
		unsigned int f = nrow[i-1]; // la fila "física" usada para acceder a la matriz
		if (i > getCol()) {
			// las últimas filas deben estar en cero
			if (!tieneFilaEnCero(f) || !b.tieneFilaEnCero(f)) {
				rv = false; // indeterminado o incompatible
				break;
			}
		}
		else {
			// Una de las primeras filas. Buscar el elemento pivote de mayor valor absoluto,
			// haciendo intercambio de filas (un intercambio simulado, se intercambian los
			// índices a filas en la tabla nrow[])
			uint_t filaMejorPivote = i;
			uint_t columna = i;
			while (columna <= getCol()) {
				filaMejorPivote = i;
				f = nrow[filaMejorPivote-1];
				long double mejorPivote = abs(sub(f, columna));
				for (uint_t j = i+1; j <= getFil(); j++) {
					// Ver si el elemento sub(nrow[j-1], i) es un mejor pivote
					long double candidato = abs(sub(nrow[j-1], columna)); 
					if (candidato > mejorPivote) {
						mejorPivote = candidato;
						filaMejorPivote = j;
					}
				}
				if (mejorPivote < EPSILON) {
					// Problema: tenemos la columna i-ésima en cero a partir de la fila i en adelante
					// El sistema es indeterminado.
					// Proseguir el algoritmo, tomando como elemento pivote el de la próxima columna
					columna++;
				}
				else
					break; // OK, seguir el algoritmo
			}
			if (columna > getCol()) {
				rv = false; // indeterminado o incompatible
				break;
			}
			
			// Intercambiar (simuladamente) las filas si corresponde
			if (i != filaMejorPivote) {
				uint_t tmp = nrow[filaMejorPivote-1];
				nrow[filaMejorPivote-1] = nrow[i-1];
				nrow[i-1] = tmp;
			}
			
			// Para cada fila a partir de i+1 restar un múltiplo conveniente de la fila i
			for (uint_t j = i+1; j <= getFil(); j++) {
				unsigned int fi = nrow[i-1];
				unsigned int fj = nrow[j-1];
				if (abs(sub(fj, columna)) >= EPSILON) {
					//long double mi = sub(fj, columna) / sub(fi, columna); // multiplicador
					long double mi = sub(fj, columna); // multiplicador
					long double di = sub(fi, columna); // divisor
					sub(fj, columna) = 0.0;
					for (uint_t k = columna+1; k <= getCol(); k++) {
          			long double thissubfjk = sub(fj, k) - mi * sub(fi, k) / di; 
                // E(j) - mi*E(i) -> E(j)
                if (-EPSILON < thissubfjk && thissubfjk < EPSILON)
                			thissubfjk = 0.0;
								sub(fj, k) = thissubfjk;
          }
					for (uint_t k = 1; k <= b.getCol(); k++) {
              long double bsubfjk = b.sub(fj, k) - mi * b.sub(fi, k) / di; 
              // b.E(j) - mi*b.E(i) -> b.E(j)
              if (-EPSILON < bsubfjk && bsubfjk < EPSILON)
              		bsubfjk = 0.0;
							b.sub(fj, k) = bsubfjk;
          }
				}
				else {
					sub(fj, columna) = 0.0;
				}
			}
		}
	}

	// Aplicar los intercambios de filas hechos
	for (uint_t i = 1; i <= getFil(); i++) {
		uint_t f = nrow[i-1]; // fila real en la matriz
		// Colocar la fila real en la fila i-ésima, intercambiando si corresponde
		if (i != f) {
		
			// Intercambiar las filas i-ésima y f-ésima
			for (uint_t k = 1; k <= getCol(); k++) {
				long double tmp = sub(i, k);
				sub(i, k) = sub(f, k);
				sub(f, k) = tmp;
			}
			
			// También intercambiar en el valor b
			for (uint_t k = 1; k <= b.getCol(); k++) {
				long double tmp = b.sub(i, k);
				b.sub(i, k) = b.sub(f, k);
				b.sub(f, k) = tmp;
			}
			
			// Indicar en la tabla nrow que esas filas fueron intercambiadas
			// Buscar cuál elemento en la tabla nrow apuntaba a la fila física i y cambiarlo a f
			for (uint_t k = i + 1; k <= getFil(); k++)
				if (nrow[k-1] == i) {
					nrow[k-1] = f; //la que antes era la fila física i ahora está en la fila física f
					break;
				}
			nrow[i-1] = i;
		}
	}
	return rv;
}
\end{verbatim}
\end{scriptsize}
\newpage

\begin{scriptsize}
\begin{verbatim}
/**
 * Despejar la matriz
 * Como precondición, la matriz debe corresponder a un sistema triangulado superiormente,
 * de M x N, con las primeras N filas distintas de cero y las restantes (si hay) en cero.
 */
 
void clase::despejar(clase& b) {

	assert(b.getFil() == getFil()); // deben tener la misma cantidad de columnas
	assert(clase::esDeterminado(b));

	// Modificar la matriz *this y también los valores de la matriz resultado b
	for (uint_t i = getFil(); i > 0; i--) {
		if (i > getCol()) {
			// La fila debe estar toda en cero, tanto para esta matriz como para la matriz b
			assert(tieneFilaEnCero(i) && b.tieneFilaEnCero(i));
		}
		else {
		
			// Los primeros i - 1 elementos deben estar en cero
			for (uint_t j = 1; j < i; j++)
				assert(sub(i, j) == 0.0); // o usar una tolerancia
			assert(sub(i, i) != 0.0); // no puede ser cero!!!
			
			// El valor debe ser 1.0
			long double pivote = sub(i, i);
			if (pivote != 1.0) {
				sub(i, i) = 1.0;
				// Multiplicar toda la fila i-ésima de b por 1/pivote
				b.multiplicarFilaPorEscalar(i, 1.0/pivote);
			}
			
			// Ahora despejar con este valor las filas 1 .. i-1
			for (uint_t k = 1; k < i; k++) {
				pivote = sub(k, i);
				
				if (abs(pivote) >= EPSILON) {
					sub(k, i) = 0.0;
					
					// Restar de la fila k de la matriz b, la fila i multiplicada por el pivote
					b.sumarMultiploDeFila(k, -pivote, i, 1);
				}
			}
		}
	}
}
\end{verbatim}
\end{scriptsize}

\begin{scriptsize}
\begin{verbatim}
void hacerDeterminado(Matriz& A, Matriz& B, AnalisisMatriz& am) {
	assert(am.esTriangularSuperiorYDespejable && am.esIndeterminado && A.getFil() >= 
	A.getCol());
	// La matriz A corresponde a un sistema indeterminado.
	// Por lo tanto tiene algunas filas en cero, correspondientes a variables 
	// que no puede despejar.
	// Vamos a convertirlo a un sistema determinado, agregando ecuaciones de la forma
	// eje(i) = 0
	// Recorrer la matriz buscando variables sin un valor definido.
	// Sabemos que la matriz tiene am.cantFilasDistintasDeCero filas que no son todas cero.
	// Agregar las nuevas ecuaciones en las filas siguientes
	unsigned int proxFila = am.cantFilasDistintasDeCero + 1;
	unsigned int i = 1;
	for (unsigned int j = 1; j <= A.getCol(); j++) {
		// Si el valor A(i,j) == 0, tenemos la variable j-ésima indeterminada
		if (abs(A.sub(i, j)) == 0.0) {
			// Agregar una ecuación de la pinta x(j-esimo) = 0
			A.sub(proxFila, j) = +1.0;
			B.multiplicarFilaPorEscalar(proxFila, 0.0); // innecesario. Si fuera distinto 
			// de cero sería incompatible
			// Ubicar a la siguiente fila para las ecuaciones agregadas
			proxFila++;
		} 
		else {
			// El x(j-esimo) puede despejarse. Saltar a la siguiente fila y variable
			i++;
		}
	}
}
\end{verbatim}
\end{scriptsize}
\newpage

\begin{scriptsize}
\begin{verbatim}
int calcular(InfoMatriz& im, string salidaMatriz) {
    std::ostream &log = logger::getLogger();
    // Resolver el sistema de ecuaciones
    // Triangular
    bool ok = im.matriz.triangular(im.balances);
    // Ver si el sistema es incompatible
    AnalisisMatriz am = im.matriz.analizarMatriz(im.balances);
    if (!am.esTriangularSuperiorYDespejable) {
    	im.matriz.show(log);
    	return 255;
    }
    if (am.esIncompatible) {
    	im.matriz.show(log);
    	im.balances.show(log);
    	return 196;
    }
    // Ver si el sistema es indeterminado. En este caso admite múltiples soluciones.
    // Asignar valores para reducirlo a un sistema determinado, y luego despejar
    if (am.esIndeterminado) {
    	hacerDeterminado(im.matriz, im.balances, am); // agregar filas a la matriz 
    	// para que pueda despejarse
    	im.matriz.show(log);
		  im.balances.show(log);
      im.matriz.triangular(im.balances); // hacer que quede triangular
    	am = im.matriz.analizarMatriz(im.balances);
    	if (!am.esDeterminado) {
    		return 128;}
    }
    // Chequear que el sistema sea determinado
    assert(am.esDeterminado);
	// Exportar la matriz para poder calcular su número de condición con Matlab
	if(salidaMatriz != "") {
        ofstream salida_matlab(salidaMatriz.c_str());
        if (!salida_matlab.is_open() || !salida_matlab.good()) {
            return 240;}
		  // sabemos que la matriz es determinada, entonces las últimas filas están
		  // en cero. No es necesario exportarlas.
        im.matriz.show_csv(salida_matlab, 1, im.matriz.getCol(), 1, im.matriz.getCol());
        salida_matlab.close();
    }
	im.matriz.despejar(im.balances);
	im.matriz.show(log);
	im.balances.show(log);
	// Volcar el resultado al grafo, asignando dirección y flujo a cada eje
	set<unsigned int> ejes = im.grafo.getEjes();
	set<unsigned int>::iterator itEjes;
	for (itEjes = ejes.begin(); itEjes != ejes.end(); itEjes++) {
		// Obtener el eje
		Grafo<InfoNodo, InfoEje>::Eje eje = im.grafo.getEje(*itEjes);
		// Obtener su flujo
		long double flujoEje = im.balances.sub(*itEjes, 1);
		if (flujoEje < 0) {
			// Invertir el sentido del eje
			eje.invertirSentido();
			flujoEje = -flujoEje;
		}
		// Asignar el valor del flujo
		InfoEje infoEje;
		infoEje.flujo = flujoEje;
		eje.setInfoUsuario(infoEje);
	}
  return 0;}
\end{verbatim}
\end{scriptsize}
\newpage

\begin{scriptsize}
\begin{verbatim}
InfoMatriz leerDe(std::istream& in)
{	...
	...
	...
	 // Agregar las ecuaciones de los nodos en la matriz
		set<unsigned int> ejes = rv.grafo.getEjes();
		//set<unsigned int>::iterator it;
		for (it = ejes.begin(); it != ejes.end(); it++) {
			// Para cada nodo debe cumplirse la ecuación
			// 	 SUMA(flujo saliente) - SUMA(flujo entrante) = balance
			// Si para un nodo un eje es saliente, se agrega un +1 a la matriz; 
			// eso significa que el eje está sumandole al balance del nodo.
			// En cambio, si el eje es entrante hay que agregarlo como -1 a la matriz
			Grafo<InfoNodo, InfoEje>::Eje eje = rv.grafo.getEje(*it);
			rv.matriz.sub(eje.getNodoOrigen(), *it) = +1.0; // es saliente del nodo origen
			rv.matriz.sub(eje.getNodoDestino(), *it) = -1.0; // es entrante al nodo destino
		}
  	// Agregar las restricciones de Morley en la matriz
		// Las restricciones de Morley dicen: el flujo en cada eje del backbone es igual.
		// En nuestra implementación exigimos además que todos los ejes del backbone tengan
		// el mismo sentido y el backbone sea lineal, para poder resolver el problema con un
		// sistema de ecuaciones planteado en una matriz.
		// Planteadas como ecuaciones, las restricciones son:
		//     eje(i) == eje(j)
		// y para llevar a una matriz:
		//     eje(i) - eje(j) = 0
		int fila = rv.grafo.getCantNodos(); // colocar a partir de esta fila las 
		// ecuaciones de la restricción de Morley
		if (rv.listaEjesBackbone.size() >= 2) {
			list<unsigned int>::iterator itLista = rv.listaEjesBackbone.begin();
			unsigned int prevEjeId = *itLista; // como la lista tiene al menos un 
			// elemento, esto no se pincha
			for (itLista++; itLista != rv.listaEjesBackbone.end(); itLista++) {
				unsigned int proxEjeId = *itLista;
				fila++;
				rv.matriz.sub(fila, prevEjeId) = +1.0;
				rv.matriz.sub(fila, proxEjeId) = -1.0;
				rv.balances.sub(fila, 1) = 0.0; // innecesario (balances se inicializa a 0)
				// preparar para la siguiente ecuación
				prevEjeId = proxEjeId;
			}
}
\end{verbatim}
\end{scriptsize}

