\subsection{An\'alisis previo al desarrollo en computadora}

\subsubsection{Plataforma y compilador}

La primer decisi\'on a tomar consiste en plataforma y compilador a utilizar. Como el desarrollo debe cumplir con el requisito de poder compilarse y ejecutarse con el software disponible en los laboratorios del Departamento de Computaci\'on, optamos por computadoras con procesadores compatibles con la arquitectura Intel x86, y el compilador g++ de la Free Software Foundation.

\subsubsection{Alternativas de representaci\'on}

Como se coment\'o en la secci\'on anterior, inicialmente se hab\'ia planteado establecer dos ejes entre cada par de nodos conectados en el problema de entrada, con sentidos opuestos.
Pero una soluci\'on equivalente es tener s\'olo un eje entre dos nodos conectados, y hacerlo dirigido dentro del programa, al leer la instancia del problema. El sentido asignado puede ser cualquiera: una vez resuelto el sistema, si el valor del flujo en el eje queda negativo, se invierten el sentido del eje y el valor del flujo el\'ectrico.

Planteada esta necesidad, dise\~namos una clase \emph{template} Grafo simple, que representa a un grafo dirigido con informaci\'on arbitraria asignada a los nodos y a los ejes. A los nodos se asign\'o una estructura de datos que indica el tipo de nodo (Nodo Concentrador o Central Generadora) y el balance si es una central generadora (valor en punto flotante). Y a los ejes se asigna el flujo (este dato se asigna luego de resolverse el sistema de ecuaciones; inicialmente queda en cero y no es utilizado).

Tambi\'en se dise\~n\'o una clase Matriz cuyos elementos son \textbf{long double}, y soporta las operaciones est\'andar del \'algebra de matrices, e implementa operaciones para resolver sistemas de ecuaciones mediante eliminaci\'on gaussiana con pivoteo parcial, como se describir\'a m\'as adelante.

\subsubsection{Planteo del sistema lineal de ecuaciones}

Como ya adelantamos en la secci\'on previa, se tomar\'a una instancia del problema y se plantear\'a un sistema lineal de ecuaciones.
Las inc\'ognitas ser\'ian los flujos de los ejes, por lo tanto el sistema tendr\'a tantas columnas como ejes existan en el grafo de entrada.
Las ecuaciones que afectan a esos ejes son de dos tipos:
\begin{itemize}
\item Ecuaciones relativas al balance de cada nodo: son las que cumplen con las condiciones (i), (ii) y (iii) del Enunciado. Las ecuaci\'ones establecen que la suma de los flujos salientes de un nodo menos la suma de los flujos entrantes al nodo debe corresponder exactamente al balance del nodo; trasladado a la matriz, esto define una fila para cada nodo, donde hay un valor $+1$ si un eje es saliente del nodo, $-1$ si el eje es entrante al nodo, y $0$ si no es incidente al nodo. El valor colocado en la matriz $b$ de valores es justamente el balance del nodo. Se define el balance de un Nodo Concentrador como $0$. Hay una fila por cada nodo.
\item Ecuaciones que establecen la restricci\'on de Morley: son las que cumplen la condici\'on (iv) del Enunciado, o sea, dicen que el flujo es id\'entico en cada eje del \emph{backbone}. Estas ecuaciones se plantearon como una cadena de igualdades: el flujo del primer eje del backbone es igual al flujo del segundo; el flujo del segundo es igual al del tercero; etc. En la matriz del sistema lineal, se agrega una fila por cada una de estas igualdades, y la forma general es colocar un $+1$ en la columna del eje \emph{i-\'esimo} y $-1$ en la columna del eje siguiente, dejando los dem\'as valores de la fila en $0$ y asignando un valor $0$ en la matriz $b$ de valores. Esta fila equivale a la ecuaci\'on $x_i = x_{i+1}$ o equivalentemente $x_i - x_{i+1} = 0$.
\end{itemize}
Ya que (en el peor caso) para un grafo de $m$ ejes se tendr\'ian que todos forman parte del backbone, inicialmente reservamos $m-1$ filas para las ecuaciones de restricciones de Morley, adem\'as de $n$ filas para cada ecuaci\'on de conservaci\'on de balance de los nodos. Esta (incorrecta) decisi\'on de tener una matriz no cuadrada trajo el grave perjuicio de asignar y utilizar mucha m\'as memoria de la necesaria, lo cual afect\'o al tiempo de c\'alculo y nos impidi\'o implementar el c\'alculo del n\'umero de condici\'on dentro del programa. M\'as tarde se modific\'o la lectura de instancias del problema para utilizar menos memoria y tener una matriz cuadrada. Se comentar\'a sobre este punto en la secci\'on Discusi\'on.

\subsubsection{Entrada y salida}

Dise\~namos un formato muy simple de entrada para el programa: numerar cada nodo y cada eje, declarar si un nodo es Nodo Concentrador o Central Generadora, y en el segundo caso especificar el balance (positivo, cero o negativo) con un valor en punto flotante.

En cambio la salida del programa fue evolucionando a medida que se encontraban inconvenientes. Inicialmente se hizo un volcado de los balances de los ejes, pero esto resulta insuficiente para expresar la orientaci\'on de los ejes, y m\'as a\'un, es de utilidad s\'olo para depurar el algoritmo y usar instancias peque\~nas del problema.

Con esta necesidad en mente se busc\'o la manera de producir un resultado m\'as \'util, y que permita verificar instancias grandes del problema. Luego de hacer distintas consultas, encontramos el software para manipulaci\'on de grafos Visone (www.visone.info) que permite importar grafos en una variedad de formatos de entrada, y asignar posici\'on, forma y color a nodos y ejes, permitiendo generar un resultado visual satisfactorio que nos permiti\'o:
\begin{itemize}
\item producir la representaci\'on de los grafos en este informe
\item verificar visualmente la correctitud del algoritmo, incluso con instancias muy grandes.
\end{itemize}

Evaluamos los formatos de entrada de Visone, y encontramos que el formato Pajek Graph es relativamente sencillo de generar desde nuestra implementaci\'on y a la vez lo suficientemente expresivo, ya que permite asignar a los nodos una forma, tama\~no, color, texto, y a los ejes un sentido y un texto. Con estos elementos, el algoritmo puede producir una diferencia visual (en el color) entre nodos concentradores y los nodos correspondientes a centrales, y dibujar el sentido correcto y el flujo asignado a todos los ejes del grafo.

M\'as tarde surgi\'o la necesidad de generar instancias de prueba de gran tama\~no para medir el rendimiento de la implementaci\'on, y encontrar el tama\~no m\'aximo del problema que puede resolverse en 10 minutos (como se pidi\'o en el Enunciado). Visone puede generar grafos aleatoriamente y exportarlo en distintos formatos. Desafortunadamente encontramos inconvenientes al exportar grafos grandes en formato Pajek Graph (sospechamos que se debi\'o a falta de memoria para trabajar) y encontramos otro formato, UCINET DL, f\'acil de procesar para leer grafos.

A la implementaci\'on entonces se agreg\'o un m\'odulo que convierte grafos en formato UCINET DL en instancias de entrada v\'alidas del problema, utilizando el texto escrito en los nodos como indicaci\'on del tipo de nodo (Nodo Concentrador o Central Generadora) y el balance del nodo (s\'olo para centrales).

Resultaba insuficiente para grafos grandes asignarle un tipo a todos los nodos, incluso usando las herramientas de manipulaci\'on masiva de nodos de Visone. Por lo tanto se modific\'o el m\'odulo de importaci\'on de grafos UCINET DL para asumir que nodos sin tipo y balance sean centrales generadoras con balance cero.

\subsubsection{C\'alculo del n\'umero de condici\'on}

Se opt\'o por realizar el c\'alculo del n\'umero de condici\'on fuera del programa, usando el software Matlab (www.mathworks.com), presente en los laboratorios de la Facultad.
Era posible realizarlo dentro del programa, pero ten\'iamos un inconveniente: la matriz sobre la cual aplicar\'iamos el c\'alculo no ser\'ia cuadrada. Con lo cual no podr\'iamos utilizar ninguna implementac\'ion de n\'umero de condici\'on que dependiera de encontrar la inversa de una matriz.
Matlab resuelve el problema, permitiendo el c\'alculo del n\'umero de condici\'on mediante la norma-2 de cualquier matriz, inclusive si no son cuadradas.

Se modific\'o la implementaci\'on para que exporte (opcionalmente) la matriz del sistema de ecuaciones en formato CSV (valores separados por comas) que puede importarse f\'acilmente en Matlab para calcular el n\'umero de condici\'on.

Como se ver\'a en la secci\'on siguiente, no contamos inicialmente con una matriz que represente un sistema determinado, o al menos, no puede garantizarse. Depende del problema de entrada.
Para no obtener un n\'umero de condici\'on infinito o muy alto con Matlab (se\~nal de que la matriz no es inversible) se realiza la exportaci\'on luego de que la implementaci\'on asegura que el sistema de ecuaciones es determinado, o sea, que la matriz es inversible.

\subsubsection{Algoritmo para resolver el sistema lineal de ecuaciones}

Desde el primer momento optamos por implementar el cl\'asico algoritmo de eliminaci\'on gaussiana con sustituci\'on hacia atr\'as, sin embargo hay distintas variantes disponibles.

Una t\'ecnica que combina simplicidad y reduce el error num\'erico es la eliminaci\'on gaussiana con pivoteo parcial [ver Burden, cap. 6, algoritmo 6.2], que finalmente fue elegida para nuestra implementaci\'on.

Sin embargo, hay una cuesti\'on importante a tener en cuenta: la matriz asociada al sistema lineal no es cuadrada\footnote{Debido a que inicialmente para un grafo de $n$ nodos y $m$ ejes reservamos $n+m-1$ filas y $m$ columnas. Al hacer pruebas con grafos con miles de ejes notamos la ineficiencia y cambiamos la implementaci\'on para que la matriz sea cuadrada}: salvo instancias muy sencillas, tenemos siempre m\'as ecuaciones que inc\'ognitas.
Lejos de representar a un sistema incompatible, encontramos que las instancias del problema corresponden a sistemas indeterminados; la eliminaci\'ion gaussiana tradicional se detendr\'ia con error porque para alguna columna, no habr\'ia ning\'un elemento candidato a ser pivote (todos los valores de dicha columna a partir de esa fila en adelante ser\'ian $0$)\footnote{Este inconveniente a\'un ser\'ia posible en la nueva implementaci\'on que define un sistema con una matriz cuadrada, ver secci\'on Discusi\'on}.

Por lo tanto nos alejamos del algoritmo tradicional aplicando estos cambios:

\begin{itemize}
\item Si para una fila no se encuentra un elemento pivote, porque todos los valores en la columna desde esa fila hacia abajo est\'an en cero, el algoritmo `avanza'\thinspace a la siguiente columna y vuelve a buscar un pivote. El efecto neto es que se produce una matriz `cuasi-triangular', que puede llevarse a una matriz triangular insertando filas para definir el valor de la columna para la que no pudo encontrarse el pivote.

\item Se separ\'o la triangulaci\'on que produce la eliminaci\'on gaussiana de la fase final de sustituci\'on hacia atr\'as, en dos m\'etodos separados. El objetivo es tener la posibilidad de aplicar entre una fase y otra un proceso que defina valores para las columnas que hayan quedado sin un elemento pivote. Entonces, en nuestra implementaci\'on tenemos una eliminaci\'on gaussiana sin sustituci\'on hacia atr\'as en el m\'etodo \emph{elimGauss} y una sustituci\'on hacia atr\'as en el m\'etodo \emph{despejar}.

\end{itemize}

Se cre\'o un m\'etodo, al que denominamos \emph{hacerDeterminado}, que agrega filas a la matriz resultante de \emph{elimGauss}, para definir un valor a las columnas sin elemento pivote. El m\'etodo agrega una fila donde todos los elementos son cero, salvo un valor $1.0$ en la columna a definir; en la matriz $b$ de valores se define el valor $0.0$. Esto equivale a definir $x_i = 0$ para esa columna; es natural en el marco del problema suponer que si no se tiene informaci\'on (restricciones) sobre el flujo de un eje, \'este sea cero.

\subsubsection{Errores de redondeo}

Durante la etapa de desarrollo no se encontraron errores de redondeo; eso se debi\'o a que tratamos con instancias muy peque\~nas y con balances enteros.
Al realizar mediciones con grafos grandes, con balances aleatorios y no enteros, se produjeron numerosos errores de redondeo que se manifestaban en que el sistema de ecuaciones ser\'ia incompatible.
Por lo tanto se modificaron los m\'etodos relativos a la resoluci\'on del sistema de ecuaciones para agregar una tolerancia: en lugar de hacer comparaciones por un valor exactamente igual a $0.0$, se pidi\'o que el valor se encuentre a una distancia m\'axima \emph{EPSILON} de $0.0$.

Adicionalmente toda vez que se detecte como resultado de un c\'alculo un valor cercano a $0$, se almacena el valor exacto $0.0$.

Esto ayud\'o a eliminar errores incluso en matrices con un n\'umero de error relativamente alto (el m\'aximo que observamos en nuestras pruebas fue del orden de $9000$).

%----------------------------------------------------------------------------------------------%
