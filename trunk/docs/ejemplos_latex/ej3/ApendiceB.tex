\section{Apéndice B}

\subsection{Funciones Relevantes}

\subsubsection{M\'etodo Simplex revisado}
\begin{scriptsize}
\begin{verbatim}
simplex(const Matriz& pc, const Matriz& pA, const Matriz& pb, Matriz& px)
{
  ------------------------------ PRECONDICION -------------------------------------
  assert(pA.getFil() == pb.getFil() && pc.getFil() == px.getFil() && pc.getFil() == 1);
  assert(pA.getCol() == pc.getCol() && pA.getCol() == px.getCol() );
  assert(pb.getCol() == 1);  assert(todosPositivos(pb));
  -------------------- INICIALIZACION DE VARIABLES DEL SIMPLEX --------------------
  
  /* Todas las matrices que se van a crear a continuacion pueden ser 
   * modificadas durante las diferentes iteraciones del algoritmo:
   * B, A_n, x_b, x_n, xval_b, c_b, c_n.
   */
  
  // Inicialmente las variables desconocidas son las slack variables: construimos
  // la matriz B como matriz identidad, para que al hacer B.xval_B se tengan los
  // valores de los terminos independientes de cada ecuacion
  // 1_ Construyo B (en su defecto A_b) como la matriz identidad.
  unsigned int m = pA.getFil();
  unsigned int n = pA.getCol();
  Matriz B = Matriz::identidad(m);

  // 2_ Construyo A_n como una copia de pA.
  Matriz A_n(pA);
 
  // 3_ Construyo x_b con los indices de las variables base.
  Matriz x_b(m, 1);
  for (int i=1; i<=m; i++)
    x_b.insertar(i, 1, n+i);

  // 4_ Construyo x_n con los indices de las variables no base.
  Matriz x_n(1,n);
  for(int i=1; i<=n; i++)
    x_n.insertar(1, i, i);

  // 5_ Construyo los valores de las variables de x_b, xval_b. Inicialmente 
  // estos valores se corresponden con los valores del parámetro de entrada pb.
  // Se obtienen de resolver la ecuación correspondiente para valores de x's 
  // no base igual a cero. 
  //  Matriz pbTranspuesta = pb.transpuesta(); 
  Matriz xval_b(pb); 
  // z = c.x entonces como z = 5x1+4x2+3x3 queda c_n = (5,4,3) y c_b = (0,0,0)

  // 6_ Construyo c_b inicialmente todos 0's.
  Matriz c_b(1, m, 0);
  // 7_ Construyo c_n inicialmente los coeficientes de Z.
  Matriz c_n(pc);
  
  ---------------------------------- ITERACION -------------------------------
  int cantIter = 0; 
  while (true) {
    cantIter++;

    /* 1_ Resolver el sistema y.B = c_b
     * Resuelvo el sistema B traspuesta. y traspuesta = c_b traspuesta
     * Luego traspongo.
     */
    Matriz y; 
    bool gaussOk = y.resolverxAb(B, c_b);
    assert(gaussOk);

    /* 2_ Buscar j tal que c_n_j - y.A_n_j > 0. 
     * Si no existe j entonces terminar: Estoy en el óptimo.
     * Si existe j entonces sea j1 el indice ir al paso 3_.
     * Si existe más de uno eligo al primero contando de izquierda a derecha.
     *
     * Notar que lo que estoy haciendo es ver si existe algun valor positivo en los
     * coeficientes que acompañan a las x's de z. Donde z = c_b.B-1.b + (c_n - c_b.B.An)x_n
     * La búsqueda se efectua sobra los valores de (c_n - c_b.B.An) !!!
     */
    int j1;
    Matriz enteringColumn;
    j1 = buscarEnteringColumn(enteringColumn, A_n, c_n, y, x_n);
    if (j1 < 0) {
      // No encontre Indice. No hay valores positivos entonces tengo la
      // solución óptima. Cargamos la solución en el vector px.
      escribirSolucion(x_b, xval_b, px );
      cout << "Encontre la solucion óptima despues de " << cantIter << " iteraciones." << endl;
      return true;
    }

    /* 3_ Resolver B.d = columna j1 de A_n.
     * Obtengo el vector correspondiente a la columna j1 de A.
     * Llamemosla a. Dado a obtengo el valor de d resolviendo el sistema
     * B.d = a.
     */
   	Matriz d; // (B.getCol(),1)
    gaussOk = d.resolverAxb(B, enteringColumn);
    assert(gaussOk);
   	 
    /* 4_ Calcular el máximo t tal que xval_b - t.d >= 0.
     *
     * t_i >= xval_b_i / d_i
     *
     * si no existe en d un valor distinto de cero entonces FIN "problema no acotado".
     * si No Existe t entonces FIN "problema no acotado".
     * si Existe entonces sea j0 el índice que impuso el límite
     * ir a 5_
     */
   	long double t = 0;
    if (!alMenosUnoDistintoDeCero(d)) { //UNBOUNDED
 	    cout<<"T: "<<t<<", Problema no acotado"<<endl;system("pause");
 	    escribirSolucion(x_b, xval_b, px );
      return false; //UNBOUNDED
    }
    int j0 = obtenerT(xval_b, d, t, x_b);
    if (j0 < 0) { //UNBOUNDED
 	    cout<<"T: "<<t<<", Problema no acotado"<<endl;system("pause");
 	    escribirSolucion(x_b, xval_b, px );
      return false; //UNBOUNDED
    }
    
    /* 5_ Vamos a acomodar todo para poder seguir iterando.
     *
     * B = B - Aj0 + Aj1.
     * A_n = A_n + Aj0 - Aj1
     * xval_b = xval_b - t. Aj1  // t es el valor obtenido anteriormente.
     * x_n_j1 = t 
     *
     * Aclaraciones j0 vive en las variables BASE y j1 en las NO BASE.
     */
   
    actualizarBaseNoBase(B, j0, A_n, j1);
    actualizarXVAL_B(xval_b, t, d);
    xval_b.sub(j0, 1) = t;
    assert(alMenosUnoDistintoDeCero(xval_b));
    //x_b vector Columna y x_n Fila.
    actualizarSegunIndicesSolucion(x_b, j0, x_n, j1);
    //c_b y c_n vector Columna.
    actualizarSegunIndicesCoeficientesSol(c_b, j0, c_n, j1);
  }
}
\end{verbatim}
\end{scriptsize}
\newpage

\subsubsection{Extraer la columna entrante y el \'indice original de dicha columna}
\begin{scriptsize}
\begin{verbatim}
/**
 * Busca el indice j1 de la columna ,que representa el menor valor de x
 * (Ej Si: x1, x2, x3 hacen mayor a cero la expresion me quedo con el indice que
 * referencia a x1),
 * de A_n que hace que valor c_n(j1) - (y*enteringColumn)(j1) sea mayor a cero.
 */
int buscarEnteringColumn(Matriz& enteringColumn, const Matriz& A_n,
  const Matriz& c_n, const Matriz& y, const Matriz& x_n)
{
  assert(y.getCol() == A_n.getFil()); // Sin mucho assert's. A lo guapo!!!
  assert(c_n.getCol() == A_n.getCol());
  assert(y.getFil() == 1);
  assert(c_n.getFil() == 1);
  // Todavía no sabemos si existe valor mayor a cero. Menos todavia el x que lo representa.
  int j1 = -1;
  for (int j = 1; j <= A_n.getCol(); j++) {
   	A_n.obtenerColumna(j, enteringColumn);
   	long double valor_actual = c_n.sub(1, j) - (y * enteringColumn).sub(1, 1);
   	if (valor_actual > 0 && ( j1 <= 0 || menorNoBase(j, j1, x_n)) ) {
      j1 = j;
    }
  }
  if (j1 > 0)
    A_n.obtenerColumna(j1, enteringColumn);
  return j1;
}
\end{verbatim}
\end{scriptsize}
\newpage

\subsubsection{Obtener $t$}

El valor de retorno '\'indice' representa el número de columna de la matriz $xval_b$
y de la matriz $d$ donde se tiene el mínimo $xval_b - t.d$, este mínimo existe
y es cero.
Se devuelve -1 si ese mínimo no existe, porque para cualquier valor de t != 0
se tiene $xval_b - t.d < 0$.\\

\begin{scriptsize}
\begin{verbatim}
int obtenerT(const Matriz& xval_b, const Matriz& d, long double& t, const Matriz& x_b )
{
  assert(xval_b.getFil() == d.getFil());
  assert(xval_b.getCol() == 1);
  assert(d.getCol() == 1);
    
  // Todavía no sabemos si existe un mínimo: el índice del mínimo queda en -1
  int indice = -1;
  // Dejamos nuestro mejor t en -1 (valor no válido) al principio
  t = -1;
  unsigned int i = 0;
  for ( i = 1; i <= d.getFil(); i++) {
Calculo los valores de t y busco el más chico de los positivos.
En caso de empate eligo el de menor indice.
$$xval_b - t.d >= 0$$
$$xval_b >= t.d$$
$$xval_b / d >= t -> para cada índice de estos vectores columna
	  if (d.sub(i, 1) > 0)
	  {
	    long double t_tmp = xval_b.sub(i, 1) / d.sub(i, 1);
	    if (-EPSILON < t_tmp && t_tmp < EPSILON)
	       t_tmp = 0.0;
  	  if (t_tmp >= 0.0 && (t < 0.0 || t_tmp < t || (t_tmp == t && menorBase(i, indice, x_b))) )
      {
	 	    // encontramos un mejor t (menor al anterior)
  	    t = t_tmp;
        indice = i;
      }
    }
  }
  return indice;
}
\end{verbatim}
\end{scriptsize}